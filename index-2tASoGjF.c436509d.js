!function(e,t,r,n,s){var i="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},a="function"==typeof i[n]&&i[n],o=a.cache||{},d="undefined"!=typeof module&&"function"==typeof module.require&&module.require.bind(module);function c(t,r){if(!o[t]){if(!e[t]){var s="function"==typeof i[n]&&i[n];if(!r&&s)return s(t,!0);if(a)return a(t,!0);if(d&&"string"==typeof t)return d(t);var l=Error("Cannot find module '"+t+"'");throw l.code="MODULE_NOT_FOUND",l}h.resolve=function(r){var n=e[t][1][r];return null!=n?n:r},h.cache={};var u=o[t]=new c.Module(t);e[t][0].call(u.exports,h,u,u.exports,i)}return o[t].exports;function h(e){var t=h.resolve(e);return!1===t?{}:c(t)}}c.isParcelRequire=!0,c.Module=function(e){this.id=e,this.bundle=c,this.exports={}},c.modules=e,c.cache=o,c.parent=a,c.register=function(t,r){e[t]=[function(e,t){t.exports=r},{}]},Object.defineProperty(c,"root",{get:function(){return i[n]}}),i[n]=c;for(var l=0;l<t.length;l++)c(t[l])}({fRrki:[function(e,t,r,n){var s=e("@parcel/transformer-js/src/esmodule-helpers.js");s.defineInteropFlag(r),s.export(r,"AptosTokenBridge",()=>p);var i=e("./index-DTF6KsXj.mjs"),a=e("./unsignedTransaction-BDOQhqcZ.mjs"),o=e("./aptos-BDX0H0Be.mjs"),d=Object.defineProperty,c=(e,t,r)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,l=(e,t,r)=>c(e,"symbol"!=typeof t?t+"":t,r);let u=[{name:"tokenBridgeAddress",...i.ce},{name:"chain",...(0,i.cf)()},{name:"domainSeparator",binary:"bytes",custom:(0,i.c9).encode(i.cg),omit:!0},{name:"tokenId",...i.ce},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}],h=e=>(0,i.cd)(u,e);class p{constructor(e,t,r,n){l(this,"network"),l(this,"chain"),l(this,"connection"),l(this,"contracts"),l(this,"chainId"),l(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=r,this.contracts=n,this.chainId=(0,i.b6)(t);let s=n.tokenBridge;if(!s)throw Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=s}static async fromRpc(e,t){let[r,n]=await (0,o.A).chainFromRpc(e),s=t[n];if(s.network!==r)throw Error("Network mismatch "+s.network+" !== "+r);return new p(r,n,e,s.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.toString().split(i.cg),r=await this.connection.getAccountResource({accountAddress:t[0],resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`});if(!r)throw(0,i.bA)(e.toString());return{chain:(0,i.bd)(parseInt(r.token_chain.number)),address:new i.bB(r.token_address.external_address)}}async getTokenUniversalAddress(e){return new i.bB((0,i.r).encode((0,i.aC)(e.toString()),!0))}async getTokenNativeAddress(e,t){let r=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!r)throw Error("Invalid asset address.");return new i.p(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,i.m)(e.address))throw Error("native asset cannot be a wrapped asset");let t=await this.getAssetFullyQualifiedType(e);if(!t)throw Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:(0,i.ch)(t),resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`}),(0,i.bG)(this.chain,t)}async isTransferCompleted(e){let t=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:t,data:{key_type:"vector<u8>",value_type:"u8",key:`0x${(0,i.V).Buffer.from((0,i.bD)(e.hash)).toString("hex")}`}}),!0}catch{return!1}}async getWrappedNative(){return(0,i.bG)(this.chain,i.k)}async *createAttestation(e,t){let r={chain:this.chain,address:new i.p(e)},n=await this.getAssetFullyQualifiedType(r);if(!n)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,typeArguments:[n],functionArguments:[]},"Aptos.AttestToken")}async *submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,typeArguments:[],functionArguments:[(0,i.be)(e)]},"Aptos.CreateWrappedCoinType");let r=await this.getAssetFullyQualifiedType(e.payload.token);if(!r)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,typeArguments:[r],functionArguments:[(0,i.be)(e)]},"Aptos.CreateWrappedCoin")}async *transfer(e,t,r,n,s){let a=(0,i.m)(r)?i.k:r.toString(),o=t.address.toUniversalAddress().toUint8Array(),d=(0,i.b6)(t.chain);s?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,typeArguments:[a],functionArguments:[n,d,o,0n,s]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,typeArguments:[a],functionArguments:[n,d,o,0n,0n]},"Aptos.TransferTokens")}async *redeem(e,t,r=!0){let n=t.payload.token.chain===this.chain?await this.getTypeFromExternalAddress(t.payload.token.address.toString()):await this.getAssetFullyQualifiedType(t.payload.token);if(!n)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,typeArguments:[n],functionArguments:[(0,i.be)(t)]},"Aptos.CompleteTransfer")}async getAssetFullyQualifiedType(e){return e.chain===this.chain?(0,i.ci)(e.address.toString())?e.address.toString():null:`${p.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{let{handle:t}=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).native_infos,r=await this.connection.getTableItem({handle:t,data:{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return r?[r.account_address,String.fromCharCode(...(0,i.r).decode(r.module_name)),String.fromCharCode(...(0,i.r).decode(r.struct_name))].join(i.cg):null}catch{return null}}static getForeignAssetAddress(e,t,r){if((0,i.m)(r.address))throw Error("Invalid token address");let n=h({chain:r.chain,tokenBridgeAddress:new(0,i.p)(t).toUniversalAddress(),tokenId:r.address.toUniversalAddress()});return(0,i.r).encode((0,i.aC)(n),!0)}createUnsignedTx(e,t,r=!1){return new a.A(e,this.network,this.chain,t,r)}}(0,i.bj)("Aptos","TokenBridge",p)},{"./index-DTF6KsXj.mjs":"ieLDt","./unsignedTransaction-BDOQhqcZ.mjs":"jlFJo","./aptos-BDX0H0Be.mjs":"d6zRe","@parcel/transformer-js/src/esmodule-helpers.js":"jiucr"}],jlFJo:[function(e,t,r,n){var s=e("@parcel/transformer-js/src/esmodule-helpers.js");s.defineInteropFlag(r),s.export(r,"A",()=>d);var i=Object.defineProperty,a=(e,t,r)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,o=(e,t,r)=>a(e,"symbol"!=typeof t?t+"":t,r);class d{constructor(e,t,r,n,s=!1){o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=s}}},{"@parcel/transformer-js/src/esmodule-helpers.js":"jiucr"}]},[],0,"parcelRequire94c2");
//# sourceMappingURL=index-2tASoGjF.c436509d.js.map
