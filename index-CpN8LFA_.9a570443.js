!function(e,t,r,i,n){var a="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},s="function"==typeof a[i]&&a[i],o=s.cache||{},l="undefined"!=typeof module&&"function"==typeof module.require&&module.require.bind(module);function u(t,r){if(!o[t]){if(!e[t]){var n="function"==typeof a[i]&&a[i];if(!r&&n)return n(t,!0);if(s)return s(t,!0);if(l&&"string"==typeof t)return l(t);var c=Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}f.resolve=function(r){var i=e[t][1][r];return null!=i?i:r},f.cache={};var d=o[t]=new u.Module(t);e[t][0].call(d.exports,f,d,d.exports,a)}return o[t].exports;function f(e){var t=f.resolve(e);return!1===t?{}:u(t)}}u.isParcelRequire=!0,u.Module=function(e){this.id=e,this.bundle=u,this.exports={}},u.modules=e,u.cache=o,u.parent=s,u.register=function(t,r){e[t]=[function(e,t){t.exports=r},{}]},Object.defineProperty(u,"root",{get:function(){return a[i]}}),a[i]=u;for(var c=0;c<t.length;c++)u(t[c])}({gLwle:[function(e,t,r,i){let n;var a=e("@parcel/transformer-js/src/esmodule-helpers.js");a.defineInteropFlag(r),a.export(r,"SuiAutomaticTokenBridge",()=>rA),a.export(r,"SuiTokenBridge",()=>rO),a.export(r,"getTokenCoinType",()=>rI),a.export(r,"getTokenFromTokenRegistry",()=>rx);var s=e("./index-DTF6KsXj.mjs"),o=e("./sui-Dhwkelcg.mjs");e("./index-Clp6Yk3p.mjs");var l=e("./unsignedTransaction-BD81leu1.mjs"),u=Object.defineProperty,c=(e,t,r)=>t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,d=(e,t,r)=>c(e,"symbol"!=typeof t?t+"":t,r);class f extends TypeError{constructor(e,t){let r;let{message:i,explanation:n,...a}=e,{path:s}=e,o=0===s.length?i:`At path: ${s.join(".")} -- ${i}`;super(n??o),null!=n&&(this.cause=o),Object.assign(this,a),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function h(e){return"object"==typeof e&&null!=e}function p(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function*g(e,t,r,i){var n;for(let a of(h(n=e)&&"function"==typeof n[Symbol.iterator]||(e=[e]),e)){let e=function(e,t,r,i){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});let{path:n,branch:a}=t,{type:s}=r,{refinement:o,message:l=`Expected a value of type \`${s}\`${o?` with refinement \`${o}\``:""}, but received: \`${p(i)}\``}=e;return{value:i,type:s,refinement:o,key:n[n.length-1],path:n,branch:a,...e,message:l}}(a,t,r,i);e&&(yield e)}}function*m(e,t,r={}){let{path:i=[],branch:n=[e],coerce:a=!1,mask:s=!1}=r,o={path:i,branch:n};if(a&&(e=t.coercer(e,o),s&&"type"!==t.type&&h(t.schema)&&h(e)&&!Array.isArray(e)))for(let r in e)void 0===t.schema[r]&&delete e[r];let l="valid";for(let i of t.validator(e,o))i.explanation=r.message,l="not_valid",yield[i,void 0];for(let[u,c,d]of t.entries(e,o))for(let t of m(c,d,{path:void 0===u?i:[...i,u],branch:void 0===u?n:[...n,c],coerce:a,mask:s,message:r.message}))t[0]?(l=null!=t[0].refinement?"not_refined":"not_valid",yield[t[0],void 0]):a&&(c=t[1],void 0===u?e=c:e instanceof Map?e.set(u,c):e instanceof Set?e.add(c):h(e)&&(void 0!==c||u in e)&&(e[u]=c));if("not_valid"!==l)for(let i of t.refiner(e,o))i.explanation=r.message,l="not_refined",yield[i,void 0];"valid"===l&&(yield[void 0,e])}class y{constructor(e){let{type:t,schema:r,validator:i,refiner:n,coercer:a=e=>e,entries:s=function*(){}}=e;this.type=t,this.schema=r,this.entries=s,this.coercer=a,i?this.validator=(e,t)=>g(i(e,t),t,this,e):this.validator=()=>[],n?this.refiner=(e,t)=>g(n(e,t),t,this,e):this.refiner=()=>[]}assert(e,t){return b(e,this,t)}create(e,t){return w(e,this,t)}is(e){return j(e,this)}mask(e,t){return v(e,this,t)}validate(e,t={}){return k(e,this,t)}}function b(e,t,r){let i=k(e,t,{message:r});if(i[0])throw i[0]}function w(e,t,r){let i=k(e,t,{coerce:!0,message:r});if(i[0])throw i[0];return i[1]}function v(e,t,r){let i=k(e,t,{coerce:!0,mask:!0,message:r});if(i[0])throw i[0];return i[1]}function j(e,t){return!k(e,t)[0]}function k(e,t,r={}){let i=m(e,t,r),n=function(e){let{done:t,value:r}=e.next();return t?void 0:r}(i);return n[0]?[new f(n[0],function*(){for(let e of i)e[0]&&(yield e[0])}),void 0]:[void 0,n[1]]}function T(...e){let t="type"===e[0].type,r=Object.assign({},...e.map(e=>e.schema));return t?function(e){let t=Object.keys(e);return new y({type:"type",schema:e,*entries(r){if(h(r))for(let i of t)yield[i,r[i],e[i]]},validator:e=>h(e)||`Expected an object, but received: ${p(e)}`,coercer:e=>h(e)?{...e}:e})}(r):_(r)}function S(e,t){return new y({type:e,schema:null,validator:t})}function E(){return S("any",()=>!0)}function x(e){return new y({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(let[r,i]of t.entries())yield[r,i,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${p(e)}`})}function I(){return S("boolean",e=>"boolean"==typeof e)}function O(){return S("integer",e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${p(e)}`)}function A(e){let t=p(e),r=typeof e;return new y({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${p(r)}`})}function B(){return S("never",()=>!1)}function $(e){return new y({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function U(){return S("number",e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${p(e)}`)}function _(e){let t=e?Object.keys(e):[],r=B();return new y({type:"object",schema:e||null,*entries(i){if(e&&h(i)){let n=new Set(Object.keys(i));for(let r of t)n.delete(r),yield[r,i[r],e[r]];for(let e of n)yield[e,i[e],r]}},validator:e=>h(e)||`Expected an object, but received: ${p(e)}`,coercer:e=>h(e)?{...e}:e})}function C(e){return new y({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function z(e,t){return new y({type:"record",schema:null,*entries(r){if(h(r))for(let i in r){let n=r[i];yield[i,i,e],yield[i,n,t]}},validator:e=>h(e)||`Expected an object, but received: ${p(e)}`})}function P(){return S("string",e=>"string"==typeof e||`Expected a string, but received: ${p(e)}`)}function M(e){let t=B();return new y({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){let i=Math.max(e.length,r.length);for(let n=0;n<i;n++)yield[n,r[n],e[n]||t]}},validator:e=>Array.isArray(e)||`Expected an array, but received: ${p(e)}`})}function R(e){let t=e.map(e=>e.type).join(" | ");return new y({type:"union",schema:null,coercer(t){for(let r of e){let[e,i]=r.validate(t,{coerce:!0});if(!e)return i}return t},validator(r,i){let n=[];for(let t of e){let[...e]=m(r,t,i),[a]=e;if(!a[0])return[];for(let[t]of e)t&&n.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${p(r)}`,...n]}})}function N(){return S("unknown",()=>!0)}let V=R([_({AddressOwner:P()}),_({ObjectOwner:P()}),_({Shared:_({initial_shared_version:$(P())})}),A("Immutable")]);S("SuiJsonValue",()=>!0);let D=R([_({u32:P()}),_({u64:P()}),_({f64:P()})]);_({attributes:z(P(),$(D)),featureFlags:z(P(),I()),maxSupportedProtocolVersion:P(),minSupportedProtocolVersion:P(),protocolVersion:P()}),R([P(),A("package")]);let F=_({digest:P(),objectId:P(),version:R([U(),P(),S("bigint",e=>"bigint"==typeof e)])});_({owner:V,reference:F}),_({objectId:P(),sequenceNumber:P()}),_({payment:x(F),owner:P(),price:P(),budget:P()});let K=T(F,_({type:P(),owner:V,previousTransaction:P()})),G=z(P(),E()),W=z(P(),N()),L=_({type:P(),fields:G,hasPublicTransfer:I()}),J=_({disassembled:W}),q=R([T(L,_({dataType:A("moveObject")})),T(J,_({dataType:A("package")}))]),X=_({type:P(),hasPublicTransfer:I(),version:P(),bcsBytes:P()}),H=_({id:P(),moduleMap:z(P(),P())}),Y=R([T(X,_({dataType:A("moveObject")})),T(H,_({dataType:A("package")}))]);BigInt(1e9);let Z=_({code:P(),error:C(P()),object_id:C(P()),parent_object_id:C(P()),version:C(P()),digest:C(P())}),Q=R([_({data:$(C(z(P(),P()))),error:$(C(Z))}),C(z(P(),P()))]),ee=_({objectId:P(),version:P(),digest:P(),type:$(C(P())),content:$(C(q)),bcs:$(C(Y)),owner:$(C(V)),previousTransaction:$(C(P())),storageRebate:$(C(P())),display:$(C(Q))});_({showType:$(C(I())),showContent:$(C(I())),showBcs:$(C(I())),showOwner:$(C(I())),showPreviousTransaction:$(C(I())),showStorageRebate:$(C(I())),showDisplay:$(C(I()))}),R([A("Exists"),A("notExists"),A("Deleted")]),x(K);let et=_({data:$(C(ee)),error:$(C(Z))});function er(e){if("reference"in e)return e.reference;let t=e.data;return t?{objectId:t.objectId,version:t.version,digest:t.digest}:function(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){let t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}(e)}_({objectId:P(),atCheckpoint:C(U())}),_({data:x(et),nextCursor:C($(P())),hasNextPage:I()}),R([_({details:ee,status:A("VersionFound")}),_({details:P(),status:A("ObjectNotExists")}),_({details:F,status:A("ObjectDeleted")}),_({details:M([P(),U()]),status:A("VersionNotFound")}),_({details:_({asked_version:U(),latest_version:U(),object_id:P()}),status:A("VersionTooHigh")})]),x(R([P(),_({Object:P()})]));let ei=_({address:P(),name:P()}),en=R([A("Private"),A("Public"),A("Friend")]),ea=_({abilities:x(P())}),es=_({constraints:ea,isPhantom:I()}),eo=_({TypeParameter:U()}),el=M([_({module:P(),package:P(),function:P()}),P()]);function eu(e){return!!e&&(!!("string"==typeof e||j(e,eo)||ed(e))||"object"==typeof e&&!!(j(e.Reference,ec)||j(e.MutableReference,ec)||j(e.Vector,ec)))}_({rank3Days:x(el),rank7Days:x(el),rank30Days:x(el)});let ec=S("SuiMoveNormalizedType",eu);function ed(e){if(!e||"object"!=typeof e||!e.Struct||"object"!=typeof e.Struct)return!1;let t=e.Struct;return!("string"!=typeof t.address||"string"!=typeof t.module||"string"!=typeof t.name||!Array.isArray(t.typeArguments)||!t.typeArguments.every(e=>eu(e)))}S("SuiMoveNormalizedStructType",ed);let ef=_({visibility:en,isEntry:I(),typeParameters:x(ea),parameters:x(ec),return:x(ec)}),eh=_({name:P(),type:ec}),ep=_({abilities:ea,typeParameters:x(es),fields:x(eh)}),eg=_({fileFormatVersion:U(),address:P(),name:P(),friends:x(ei),structs:z(P(),ep),exposedFunctions:z(P(),ef)});function em(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function ey(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function eb(e){if("object"==typeof e&&"Struct"in e)return e;let t=ey(e),r=em(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}z(P(),eg);var ew=function(e){if(e.length>=255)throw TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var i=0;i<e.length;i++){var n=e.charAt(i),a=n.charCodeAt(0);if(255!==t[a])throw TypeError(n+" is ambiguous");t[a]=i}var s=e.length,o=e.charAt(0),l=Math.log(s)/Math.log(256),u=Math.log(256)/Math.log(s);function c(e){if("string"!=typeof e)throw TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,i=0,n=0;e[r]===o;)i++,r++;for(var a=(e.length-r)*l+1>>>0,u=new Uint8Array(a);e[r];){var c=t[e.charCodeAt(r)];if(255===c)return;for(var d=0,f=a-1;(0!==c||d<n)&&-1!==f;f--,d++)c+=s*u[f]>>>0,u[f]=c%256>>>0,c=c/256>>>0;if(0!==c)throw Error("Non-zero carry");n=d,r++}for(var h=a-n;h!==a&&0===u[h];)h++;for(var p=new Uint8Array(i+(a-h)),g=i;h!==a;)p[g++]=u[h++];return p}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,i=0,n=0,a=t.length;n!==a&&0===t[n];)n++,r++;for(var l=(a-n)*u+1>>>0,c=new Uint8Array(l);n!==a;){for(var d=t[n],f=0,h=l-1;(0!==d||f<i)&&-1!==h;h--,f++)d+=256*c[h]>>>0,c[h]=d%s>>>0,d=d/s>>>0;if(0!==d)throw Error("Non-zero carry");i=f,n++}for(var p=l-i;p!==l&&0===c[p];)p++;for(var g=o.repeat(r);p<l;++p)g+=e.charAt(c[p]);return g},decodeUnsafe:c,decode:function(e){var t=c(e);if(t)return t;throw Error("Non-base"+s+" character")}}}("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");let ev=(0,s.X)(ew),ej=e=>ev.encode(e),ek=e=>ev.decode(e);function eT(e){return Uint8Array.from(atob(e),e=>e.charCodeAt(0))}function eS(e){if(e.length<8192)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=8192)t+=String.fromCharCode(...e.slice(r,r+8192));return btoa(t)}function eE(e){var t;let r=e.startsWith("0x")?e.slice(2):e,i=(null==(t=(r.length%2==0?r:`0${r}}`).match(/.{2}/g))?void 0:t.map(e=>parseInt(e,16)))??[];return Uint8Array.from(i)}function ex(e){return e.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function eI(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}class eO{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32();return BigInt("0x"+(this.read32().toString(16)+e.toString(16).padStart(8,"0"))).toString(10)}read128(){let e=BigInt(this.read64());return BigInt("0x"+(BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0"))).toString(10)}read256(){let e=BigInt(this.read128());return BigInt("0x"+(BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0"))).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,{value:t,length:r}=function(e){let t=0,r=0,i=0;for(;;){let n=e[i];if(i+=1,t|=(127&n)<<r,!(128&n))break;r+=7}return{value:t,length:i}}(new Uint8Array(this.dataView.buffer,e));return this.shift(r),t}readVec(e){let t=this.readULEB(),r=[];for(let i=0;i<t;i++)r.push(e(this,i,t));return r}}function eA(e,t=["<",">"]){let[r,i]=t,n=[],a="",s=0;for(let t=0;t<e.length;t++){let o=e[t];if(o===r&&s++,o===i&&s--,0===s&&","===o){n.push(a.trim()),a="";continue}a+=o}return n.push(a.trim()),n}class eB{constructor({size:e=1024,maxSize:t,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){let t=this.bytePosition+e;if(t>this.size){let e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;let r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return e$(BigInt(e),8).forEach(e=>this.write8(e)),this}write128(e){return e$(BigInt(e),16).forEach(e=>this.write8(e)),this}write256(e){return e$(BigInt(e),32).forEach(e=>this.write8(e)),this}writeULEB(e){return eI(e).forEach(e=>this.write8(e)),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach((r,i)=>t(this,r,i,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return ej(e);case"base64":return eS(e);case"hex":return ex(e);default:throw Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function e$(e,t){let r=new Uint8Array(t),i=0;for(;e>0;)r[i]=Number(e%BigInt(256)),e/=BigInt(256),i+=1;return r}var eU,e_,eC,ez,eP=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},eM=(e,t,r)=>(eP(e,t,"read from private field"),r?r.call(e):t.get(e)),eR=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},eN=(e,t,r,i)=>(eP(e,t,"write to private field"),t.set(e,r),r);let eV=class{constructor(e){eR(this,eU,void 0),eR(this,e_,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),eN(this,eU,e.write),eN(this,e_,e.serialize??((e,t)=>{let r=new eB({size:this.serializedSize(e)??void 0,...t});return eM(this,eU).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),eM(this,eU).call(this,e,t)}serialize(e,t){return this.validate(e),new eK(this,eM(this,e_).call(this,e,t))}parse(e){let t=new eO(e);return this.read(t)}transform({name:e,input:t,output:r}){return new eV({name:e??this.name,read:e=>r(this.read(e)),write:(e,r)=>eM(this,eU).call(this,t(e),r),serializedSize:e=>this.serializedSize(t(e)),serialize:(e,r)=>eM(this,e_).call(this,t(e),r),validate:e=>this.validate(t(e))})}};eU=new WeakMap,e_=new WeakMap;let eD=Symbol.for("@mysten/serialized-bcs");function eF(e){return!!e&&"object"==typeof e&&!0===e[eD]}class eK{constructor(e,t){eR(this,eC,void 0),eR(this,ez,void 0),eN(this,eC,e),eN(this,ez,t)}get[eD](){return!0}toBytes(){return eM(this,ez)}toHex(){return ex(eM(this,ez))}toBase64(){return eS(eM(this,ez))}toBase58(){return ej(eM(this,ez))}parse(){return eM(this,eC).parse(eM(this,ez))}}function eG({size:e,...t}){return new eV({...t,serializedSize:()=>e})}function eW({readMethod:e,writeMethod:t,...r}){return eG({...r,read:t=>t[e](),write:(e,r)=>r[t](e),validate:e=>{var t;if(e<0||e>r.maxValue)throw TypeError(`Invalid ${r.name} value: ${e}. Expected value in range 0-${r.maxValue}`);null==(t=r.validate)||t.call(r,e)}})}function eL({readMethod:e,writeMethod:t,...r}){return eG({...r,read:t=>t[e](),write:(e,r)=>r[t](BigInt(e)),validate:e=>{var t;let i=BigInt(e);if(i<0||i>r.maxValue)throw TypeError(`Invalid ${r.name} value: ${i}. Expected value in range 0-${r.maxValue}`);null==(t=r.validate)||t.call(r,i)}})}eC=new WeakMap,ez=new WeakMap;let eJ={u8:e=>eW({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>eW({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>eW({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:0x100000000-1,...e}),u64:e=>eL({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>eL({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>eL({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>eG({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(+!!e),...e,validate:t=>{var r;if(null==(r=null==e?void 0:e.validate)||r.call(e,t),"boolean"!=typeof t)throw TypeError(`Expected boolean, found ${typeof t}`)}}),uleb128:e=>(function({serialize:e,...t}){let r=new eV({...t,serialize:e,write:(e,t)=>{for(let i of r.serialize(e).toBytes())t.write8(i)}});return r})({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(eI(e)),...e}),bytes:(e,t)=>eG({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let i=0;i<e;i++)r.write8(t[i]??0)},...t,validate:r=>{var i;if(null==(i=null==t?void 0:t.validate)||i.call(t,r),!("length"in r))throw TypeError(`Expected array, found ${typeof r}`);if(r.length!==e)throw TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>(function({toBytes:e,fromBytes:t,...r}){return new eV({...r,read:e=>{let r=e.readULEB();return t(e.readBytes(r))},write:(t,r)=>{let i=e(t);r.writeULEB(i.length);for(let e=0;e<i.length;e++)r.write8(i[e])},serialize:t=>{let r=e(t),i=eI(r.length),n=new Uint8Array(i.length+r.length);return n.set(i,0),n.set(r,i.length),n},validate:e=>{var t;if("string"!=typeof e)throw TypeError(`Invalid ${r.name} value: ${e}. Expected string`);null==(t=r.validate)||t.call(r,e)}})})({name:"string",toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...e}),fixedArray:(e,t,r)=>new eV({name:`${t.name}[${e}]`,read:r=>{let i=Array(e);for(let n=0;n<e;n++)i[n]=t.read(r);return i},write:(e,r)=>{for(let i of e)t.write(i,r)},...r,validate:t=>{var i;if(null==(i=null==r?void 0:r.validate)||i.call(r,t),!("length"in t))throw TypeError(`Expected array, found ${typeof t}`);if(t.length!==e)throw TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>eJ.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new eV({name:`vector<${e.name}>`,read:t=>{let r=t.readULEB(),i=Array(r);for(let n=0;n<r;n++)i[n]=e.read(t);return i},write:(t,r)=>{for(let i of(r.writeULEB(t.length),t))e.write(i,r)},...t,validate:e=>{var r;if(null==(r=null==t?void 0:t.validate)||r.call(t,e),!("length"in e))throw TypeError(`Expected array, found ${typeof e}`)}}),tuple:(e,t)=>new eV({name:`(${e.map(e=>e.name).join(", ")})`,serializedSize:t=>{let r=0;for(let i=0;i<e.length;i++){let n=e[i].serializedSize(t[i]);if(null==n)return null;r+=n}return r},read:t=>{let r=[];for(let i of e)r.push(i.read(t));return r},write:(t,r)=>{for(let i=0;i<e.length;i++)e[i].write(t[i],r)},...t,validate:r=>{var i;if(null==(i=null==t?void 0:t.validate)||i.call(t,r),!Array.isArray(r))throw TypeError(`Expected array, found ${typeof r}`);if(r.length!==e.length)throw TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){let i=Object.entries(t);return new eV({name:e,serializedSize:e=>{let t=0;for(let[r,n]of i){let i=n.serializedSize(e[r]);if(null==i)return null;t+=i}return t},read:e=>{let t={};for(let[r,n]of i)t[r]=n.read(e);return t},write:(e,t)=>{for(let[r,n]of i)n.write(e[r],t)},...r,validate:e=>{var t;if(null==(t=null==r?void 0:r.validate)||t.call(r,e),"object"!=typeof e||null==e)throw TypeError(`Expected object, found ${typeof e}`)}})},enum(e,t,r){let i=Object.entries(t);return new eV({name:e,read:e=>{let[t,r]=i[e.readULEB()];return{[t]:(null==r?void 0:r.read(e))??!0}},write:(e,t)=>{let[r,n]=Object.entries(e)[0];for(let e=0;e<i.length;e++){let[a,s]=i[e];if(a===r){t.writeULEB(e),null==s||s.write(n,t);return}}},...r,validate:e=>{var i;if(null==(i=null==r?void 0:r.validate)||i.call(r,e),"object"!=typeof e||null==e)throw TypeError(`Expected object, found ${typeof e}`);let n=Object.keys(e);if(1!==n.length)throw TypeError(`Expected object with one key, found ${n.length}`);let[a]=n;if(!Object.hasOwn(t,a))throw TypeError(`Invalid enum variant ${a}`)}})},map:(e,t)=>eJ.vector(eJ.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{let t=new Map;for(let[r,i]of e)t.set(r,i);return t}}),generic:(e,t)=>(...e)=>t(...e).transform({name:`${t.name}<${e.map(e=>e.name).join(", ")}>`,input:e=>e,output:e=>e}),lazy:e=>(function(e){let t=null;function r(){return t||(t=e()),t}return new eV({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})})(e)},eq=class{constructor(e){var t;if(this.types=new Map,this.counter=0,e instanceof eq){this.schema=e.schema,this.types=new Map(e.types);return}if(this.schema=e,this.registerAddressType(eq.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);!1!==e.withPrimitives&&(t=this,t.registerType(eq.U8,function(e,t){return e.write8(t)},function(e){return e.read8()},e=>e<256),t.registerType(eq.U16,function(e,t){return e.write16(t)},function(e){return e.read16()},e=>e<65536),t.registerType(eq.U32,function(e,t){return e.write32(t)},function(e){return e.read32()},e=>e<=4294967296n),t.registerType(eq.U64,function(e,t){return e.write64(t)},function(e){return e.read64()}),t.registerType(eq.U128,function(e,t){return e.write128(t)},function(e){return e.read128()}),t.registerType(eq.U256,function(e,t){return e.write256(t)},function(e){return e.read256()}),t.registerType(eq.BOOL,function(e,t){return e.write8(t)},function(e){return"1"===e.read8().toString(10)}),t.registerType(eq.STRING,function(e,t){return e.writeVec(Array.from(t),(e,t)=>e.write8(t.charCodeAt(0)))},function(e){return e.readVec(e=>e.read8()).map(e=>String.fromCharCode(Number(e))).join("")},e=>!0),t.registerType(eq.HEX,function(e,t){return e.writeVec(Array.from(eE(t)),(e,t)=>e.write8(t))},function(e){return ex(new Uint8Array(e.readVec(e=>e.read8())))}),t.registerType(eq.BASE58,function(e,t){return e.writeVec(Array.from(ek(t)),(e,t)=>e.write8(t))},function(e){return ej(new Uint8Array(e.readVec(e=>e.read8())))}),t.registerType(eq.BASE64,function(e,t){return e.writeVec(Array.from(eT(t)),(e,t)=>e.write8(t))},function(e){return eS(new Uint8Array(e.readVec(e=>e.read8())))}))}tempKey(){return`bcs-struct-${++this.counter}`}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){let{name:i,params:n}=this.parseTypeName(e);return this.getTypeInterface(i).encode(this,t,r,n)}if("object"==typeof e){let i=this.tempKey();return new eq(this).registerStructType(i,e).ser(i,t,r)}throw Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(e)}`)}de(e,t,r){if("string"==typeof t){if(r)t=function(e,t){switch(t){case"base58":return ek(e);case"base64":return eT(e);case"hex":return eE(e);default:throw Error("Unsupported encoding, supported values are: base64, hex")}}(t,r);else throw Error("To pass a string to `bcs.de`, specify encoding")}if("string"==typeof e||Array.isArray(e)){let{name:r,params:i}=this.parseTypeName(e);return this.getTypeInterface(r).decode(this,t,i)}if("object"==typeof e){let i=new eq(this),n=this.tempKey();return i.registerStructType(n,e).de(n,t,r)}throw Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,i=()=>!0){let{name:n,params:a}=this.parseTypeName(e);return this.types.set(n,{encode(e,t,r,i){let n=a.reduce((e,t,r)=>Object.assign(e,{[t]:i[r]}),{});return this._encodeRaw.call(e,new eB(r),t,i,n)},decode(e,t,r){let i=a.reduce((e,t,i)=>Object.assign(e,{[t]:r[i]}),{});return this._decodeRaw.call(e,new eO(t),r,i)},_encodeRaw(e,r,a,s){if(i(r))return t.call(this,e,r,a,s);throw Error(`Validation failed for type ${n}, data: ${r}`)},_decodeRaw(e,t,i){return r.call(this,e,t,i)}}),this}registerBcsType(e,t){return this.registerType(e,(e,r,i)=>(t(...i.map(e=>new eV({name:String(e),write:(t,r)=>{let{name:n,params:a}=this.parseTypeName(e),s=this.getTypeInterface(n),o=a.reduce((e,t,r)=>Object.assign(e,{[t]:i[r]}),{});return s._encodeRaw.call(this,r,t,a,o)},read:()=>{throw Error("Not implemented")}}))).write(r,e),e),(e,r)=>t(...r.map(e=>new eV({name:String(e),write:(e,t)=>{throw Error("Not implemented")},read:t=>{let{name:i,params:n}=this.parseTypeName(e),a=this.getTypeInterface(i),s=n.reduce((e,t,i)=>Object.assign(e,{[t]:r[i]}),{});return a._decodeRaw.call(this,t,n,s)}}))).read(e)),this}registerAddressType(e,t,r="hex"){switch(r){case"base64":return this.registerType(e,function(e,t){return eT(t).reduce((e,t)=>e.write8(t),e)},function(e){return eS(e.readBytes(t))});case"hex":return this.registerType(e,function(e,t){return eE(t).reduce((e,t)=>e.write8(t),e)},function(e){return ex(e.readBytes(t))});default:throw Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw Error("Vector can have only one type parameter; got "+t);return this.registerType(e,function(t,r,i,n){return t.writeVec(r,(t,r)=>{let a=i[0];if(!a)throw Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:s,params:o}=this.parseTypeName(a);if(this.hasType(s))return this.getTypeInterface(s)._encodeRaw.call(this,t,r,o,n);if(!(s in n))throw Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:l,params:u}=this.parseTypeName(n[s]);return this.getTypeInterface(l)._encodeRaw.call(this,t,r,u,n)})},function(t,r,i){return t.readVec(t=>{let n=r[0];if(!n)throw Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:a,params:s}=this.parseTypeName(n);if(this.hasType(a))return this.getTypeInterface(a)._decodeRaw.call(this,t,s,i);if(!(a in i))throw Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:o,params:l}=this.parseTypeName(i[a]);return this.getTypeInterface(o)._decodeRaw.call(this,t,l,i)})})}registerStructType(e,t){for(let e in t){let r=this.tempKey(),i=t[e];Array.isArray(i)||"string"==typeof i||(t[e]=r,this.registerStructType(r,i))}let r=Object.freeze(t),i=Object.keys(r),{name:n,params:a}=this.parseTypeName(e);return this.registerType(e,function(e,t,s,o){if(!t||t.constructor!==Object)throw Error(`Expected ${n} to be an Object, got: ${t}`);if(s.length!==a.length)throw Error(`Incorrect number of generic parameters passed; expected: ${a.length}, got: ${s.length}`);for(let l of i){if(!(l in t))throw Error(`Struct ${n} requires field ${l}:${r[l]}`);let{name:i,params:u}=this.parseTypeName(r[l]);if(a.includes(i)){let r=a.indexOf(i),{name:u,params:c}=this.parseTypeName(s[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[l],c,o);continue}if(!(u in o))throw Error(`Unable to find a matching type definition for ${u} in ${n}; make sure you passed a generic`);let{name:d,params:f}=this.parseTypeName(o[u]);this.getTypeInterface(d)._encodeRaw.call(this,e,t[l],f,o)}else this.getTypeInterface(i)._encodeRaw.call(this,e,t[l],u,o)}return e},function(e,t,s){if(t.length!==a.length)throw Error(`Incorrect number of generic parameters passed; expected: ${a.length}, got: ${t.length}`);let o={};for(let l of i){let{name:i,params:u}=this.parseTypeName(r[l]);if(a.includes(i)){let r=a.indexOf(i),{name:u,params:c}=this.parseTypeName(t[r]);if(this.hasType(u)){o[l]=this.getTypeInterface(u)._decodeRaw.call(this,e,c,s);continue}if(!(u in s))throw Error(`Unable to find a matching type definition for ${u} in ${n}; make sure you passed a generic`);let{name:d,params:f}=this.parseTypeName(s[u]);o[l]=this.getTypeInterface(d)._decodeRaw.call(this,e,f,s)}else o[l]=this.getTypeInterface(i)._decodeRaw.call(this,e,u,s)}return o})}registerEnumType(e,t){for(let e in t){let r=this.tempKey(),i=t[e];null===i||Array.isArray(i)||"string"==typeof i||(t[e]=r,this.registerStructType(r,i))}let r=Object.freeze(t),i=Object.keys(r),{name:n,params:a}=this.parseTypeName(e);return this.registerType(e,function(e,t,s,o){if(!t)throw Error(`Unable to write enum "${n}", missing data.
Received: "${t}"`);if("object"!=typeof t)throw Error(`Incorrect data passed into enum "${n}", expected object with properties: "${i.join(" | ")}".
Received: "${JSON.stringify(t)}"`);let l=Object.keys(t)[0];if(void 0===l)throw Error(`Empty object passed as invariant of the enum "${n}"`);let u=i.indexOf(l);if(-1===u)throw Error(`Unknown invariant of the enum "${n}", allowed values: "${i.join(" | ")}"; received "${l}"`);let c=r[i[u]];if(e.write8(u),null===c)return e;let d=a.indexOf(c),f=-1===d?c:s[d];{let{name:r,params:i}=this.parseTypeName(f);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[l],i,o)}},function(e,t,s){let o=e.readULEB(),l=i[o],u=r[l];if(-1===o)throw Error(`Decoding type mismatch, expected enum "${n}" invariant index, received "${o}"`);if(null===u)return{[l]:!0};let c=a.indexOf(u),d=-1===c?u:t[c];{let{name:t,params:r}=this.parseTypeName(d);return{[l]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,s)}}})}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],i=e.indexOf(t),n=Array.from(e).reverse().indexOf(r);if(-1===i&&-1===n)return{name:e,params:[]};if(-1===i||-1===n)throw Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,i),params:eA(e.slice(i+1,e.length-n-1),this.schema.genericSeparators)}}};eq.U8="u8",eq.U16="u16",eq.U32="u32",eq.U64="u64",eq.U128="u128",eq.U256="u256",eq.BOOL="bool",eq.VECTOR="vector",eq.ADDRESS="address",eq.STRING="string",eq.HEX="hex-string",eq.BASE58="base58-string",eq.BASE64="base64-string";function eX(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(64,"0")}`}function eH(e,t=!1){return eX(e,t)}BigInt(1e9);let eY=eH("0x6"),eZ="0x2::sui::SUI";eH("0x5");let eQ={address:"0x2",module:"object",name:"ID"},e0={address:"0x1",module:"ascii",name:"String"},e1={address:"0x1",module:"string",name:"String"},e6={address:"0x1",module:"option",name:"Option"},e2=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function e8(e,t){if(!(typeof t>"u")&&typeof t!==e)throw Error(`Expect ${t} to be ${e}, received ${typeof t}`)}let e5=["Address","Bool","U8","U16","U32","U64","U128","U256"],e4=/^vector<(.+)>$/,e3=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class e7{static parseFromStr(e,t=!1){if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};let r=e.match(e4);if(r)return{vector:e7.parseFromStr(r[1],t)};let i=e.match(e3);if(i)return{struct:{address:t?eX(i[1]):i[1],module:i[2],name:i[3],typeParams:void 0===i[5]?[]:e7.parseStructTypeArgs(i[5],t)}};throw Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return eA(e).map(e=>e7.parseFromStr(e,t))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${e7.tagToString(e.vector)}>`;if("struct"in e){let t=e.struct,r=t.typeParams.map(e7.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw Error("Invalid TypeTag")}}let e9=new eq({genericSeparators:["<",">"],vectorType:"vector",addressLength:32,addressEncoding:"hex",types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function te(e){return eJ.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function tt(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{let t=Object.keys(e)[0];return{kind:t,...e[t]}}})}let tr=eJ.bytes(32).transform({input:e=>"string"==typeof e?eE(eX(e)):e,output:e=>eX(ex(e))}),ti=eJ.vector(eJ.u8()).transform({name:"ObjectDigest",input:e=>ek(e),output:e=>ej(new Uint8Array(e))}),tn=eJ.struct("SuiObjectRef",{objectId:tr,version:eJ.u64(),digest:ti}),ta=eJ.struct("SharedObjectRef",{objectId:tr,initialSharedVersion:eJ.u64(),mutable:eJ.bool()}),ts=eJ.enum("ObjectArg",{ImmOrOwned:tn,Shared:ta,Receiving:tn}),to=eJ.enum("CallArg",{Pure:eJ.vector(eJ.u8()),Object:ts,ObjVec:eJ.vector(ts)}),tl=eJ.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:eJ.lazy(()=>tl),struct:eJ.lazy(()=>tg),u16:null,u32:null,u256:null}),tu=tt(eJ.enum("Argument",{GasCoin:null,Input:eJ.struct("Input",{index:eJ.u16()}),Result:eJ.struct("Result",{index:eJ.u16()}),NestedResult:eJ.struct("NestedResult",{index:eJ.u16(),resultIndex:eJ.u16()})})),tc=eJ.struct("ProgrammableMoveCall",{package:tr,module:eJ.string(),function:eJ.string(),type_arguments:eJ.vector(tl),arguments:eJ.vector(tu)}).transform({input:e=>{let[t,r,i]=e.target.split("::"),n=e.typeArguments.map(e=>e7.parseFromStr(e,!0));return{package:eX(t),module:r,function:i,type_arguments:n,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(e7.tagToString)})}),td=tt(eJ.enum("Transaction",{MoveCall:tc,TransferObjects:eJ.struct("TransferObjects",{objects:eJ.vector(tu),address:tu}),SplitCoins:eJ.struct("SplitCoins",{coin:tu,amounts:eJ.vector(tu)}),MergeCoins:eJ.struct("MergeCoins",{destination:tu,sources:eJ.vector(tu)}),Publish:eJ.struct("Publish",{modules:eJ.vector(eJ.vector(eJ.u8())),dependencies:eJ.vector(tr)}),MakeMoveVec:eJ.struct("MakeMoveVec",{type:eJ.enum("Option",{None:null,Some:tl}),objects:eJ.vector(tu)}),Upgrade:eJ.struct("Upgrade",{modules:eJ.vector(eJ.vector(eJ.u8())),dependencies:eJ.vector(tr),packageId:tr,ticket:tu})})),tf=eJ.struct("ProgrammableTransaction",{inputs:eJ.vector(to),transactions:eJ.vector(td)}),th=eJ.enum("TransactionKind",{ProgrammableTransaction:tf,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),tp=eJ.enum("TransactionExpiration",{None:null,Epoch:te()}),tg=eJ.struct("StructTag",{address:tr,module:eJ.string(),name:eJ.string(),typeParams:eJ.vector(tl)}),tm=eJ.struct("GasData",{payment:eJ.vector(tn),owner:tr,price:eJ.u64(),budget:eJ.u64()}),ty=eJ.struct("TransactionDataV1",{kind:th,sender:tr,gasData:tm,expiration:tp}),tb=eJ.enum("TransactionData",{V1:ty}),tw=eJ.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),tv=eJ.enum("IntentVersion",{V0:null}),tj=eJ.enum("AppId",{Sui:null}),tk=eJ.struct("Intent",{scope:tw,version:tv,appId:tj}),tT=eJ.generic(["T"],e=>eJ.struct("IntentMessage<T>",{intent:tk,value:e})),tS=eJ.enum("CompressedSignature",{ED25519:eJ.fixedArray(64,eJ.u8()),Secp256k1:eJ.fixedArray(64,eJ.u8()),Secp256r1:eJ.fixedArray(64,eJ.u8()),ZkLogin:eJ.vector(eJ.u8())}),tE=eJ.enum("PublicKey",{ED25519:eJ.fixedArray(32,eJ.u8()),Secp256k1:eJ.fixedArray(33,eJ.u8()),Secp256r1:eJ.fixedArray(33,eJ.u8()),ZkLogin:eJ.vector(eJ.u8())}),tx=eJ.struct("MultiSigPkMap",{pubKey:tE,weight:eJ.u8()}),tI=eJ.struct("MultiSigPublicKey",{pk_map:eJ.vector(tx),threshold:eJ.u16()}),tO=eJ.struct("MultiSig",{sigs:eJ.vector(tS),bitmap:eJ.u16(),multisig_pk:tI}),tA=eJ.vector(eJ.u8()).transform({input:e=>"string"==typeof e?eT(e):e,output:e=>eS(new Uint8Array(e))}),tB=eJ.struct("SenderSignedTransaction",{intentMessage:tT(tb),txSignatures:eJ.vector(tA)}),t$=eJ.vector(tB,{name:"SenderSignedData"}),tU={...eJ,U8:eJ.u8(),U16:eJ.u16(),U32:eJ.u32(),U64:eJ.u64(),U128:eJ.u128(),U256:eJ.u256(),ULEB128:eJ.uleb128(),Bool:eJ.bool(),String:eJ.string(),Address:tr,Argument:tu,CallArg:to,CompressedSignature:tS,GasData:tm,MultiSig:tO,MultiSigPkMap:tx,MultiSigPublicKey:tI,ObjectArg:ts,ObjectDigest:ti,ProgrammableMoveCall:tc,ProgrammableTransaction:tf,PublicKey:tE,SenderSignedData:t$,SenderSignedTransaction:tB,SharedObjectRef:ta,StructTag:tg,SuiObjectRef:tn,Transaction:td,TransactionData:tb,TransactionDataV1:ty,TransactionExpiration:tp,TransactionKind:th,TypeTag:tl,ser:e9.ser.bind(e9),de:e9.de.bind(e9),getTypeInterface:e9.getTypeInterface.bind(e9),hasType:e9.hasType.bind(e9),parseTypeName:e9.parseTypeName.bind(e9),registerAddressType:e9.registerAddressType.bind(e9),registerAlias:e9.registerAlias.bind(e9),registerBcsType:e9.registerBcsType.bind(e9),registerEnumType:e9.registerEnumType.bind(e9),registerStructType:e9.registerStructType.bind(e9),registerType:e9.registerType.bind(e9),types:e9.types};e9.registerBcsType("utf8string",()=>eJ.string({name:"utf8string"})),e9.registerBcsType("unsafe_u64",()=>te()),e9.registerBcsType("enumKind",e=>tt(e)),[tr,tu,to,tS,tm,tO,tx,tI,ts,ti,tc,tf,tE,t$,ta,tg,tn,td,tb,ty,tp,th,tl].forEach(e=>{e9.registerBcsType(e.name,()=>e)});let t_=R([_({ImmOrOwned:F}),_({Shared:_({objectId:P(),initialSharedVersion:R([O(),P()]),mutable:I()})}),_({Receiving:F})]),tC=_({Pure:x(O())}),tz=_({Object:t_}),tP=R([tC,tz]),tM={Pure:function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:eF(e)?e.toBytes():tU.ser(t,e,{maxSize:1/0}).toBytes())}},ObjectRef:({objectId:e,digest:t,version:r})=>({Object:{ImmOrOwned:{digest:t,version:r,objectId:eX(e)}}}),SharedObjectRef:({objectId:e,mutable:t,initialSharedVersion:r})=>({Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:eX(e)}}}),ReceivingRef:({objectId:e,digest:t,version:r})=>({Object:{Receiving:{digest:t,version:r,objectId:eX(e)}}})};function tR(e){return"string"==typeof e?eX(e):"ImmOrOwned"in e.Object?eX(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?eX(e.Object.Receiving.objectId):eX(e.Object.Shared.objectId)}let tN=R([_({kind:A("Input"),index:O(),value:C(E()),type:C(A("object"))}),_({kind:A("Input"),index:O(),value:C(E()),type:A("pure")})]),tV=R([tN,_({kind:A("GasCoin")}),_({kind:A("Result"),index:O()}),_({kind:A("NestedResult"),index:O(),resultIndex:O()})]),tD=_({kind:A("MoveCall"),target:S("target",P().validator),typeArguments:x(P()),arguments:x(tV)}),tF=_({kind:A("TransferObjects"),objects:x(tV),address:tV}),tK=_({kind:A("SplitCoins"),coin:tV,amounts:x(tV)}),tG=_({kind:A("MergeCoins"),destination:tV,sources:x(tV)}),tW=_({kind:A("MakeMoveVec"),type:C((n=z(P(),N()),R([_({None:R([A(!0),A(null)])}),_({Some:n})]))),objects:x(tV)}),tL=_({kind:A("Publish"),modules:x(x(O())),dependencies:x(P())}),tJ=_({kind:A("Upgrade"),modules:x(x(O())),dependencies:x(P()),packageId:P(),ticket:tV}),tq=R([tD,tF,tK,tG,tL,tJ,tW]),tX=e=>w({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},tD),tH=(e,t)=>("Input"===t.kind&&"pure"===t.type&&"object"!=typeof t.value&&(t.value=tM.Pure(tU.Address.serialize(t.value))),w({kind:"TransferObjects",objects:e,address:t},tF)),tY=(e,t)=>(t.forEach(e=>{"Input"===e.kind&&"pure"===e.type&&"object"!=typeof e.value&&(e.value=tM.Pure(tU.U64.serialize(e.value)))}),w({kind:"SplitCoins",coin:e,amounts:t},tK)),tZ=(e,t)=>w({kind:"MergeCoins",destination:e,sources:t},tG),tQ=({modules:e,dependencies:t})=>w({kind:"Publish",modules:e.map(e=>"string"==typeof e?Array.from(eT(e)):e),dependencies:t.map(e=>eH(e))},tL),t0=({modules:e,dependencies:t,packageId:r,ticket:i})=>w({kind:"Upgrade",modules:e.map(e=>"string"==typeof e?Array.from(eT(e)):e),dependencies:t.map(e=>eH(e)),packageId:r,ticket:i},tJ),t1=({type:e,objects:t})=>w({kind:"MakeMoveVec",type:e?{Some:e7.parseFromStr(e)}:{None:null},objects:t},tW),t6=C($(R([_({Epoch:O()}),_({None:R([A(!0),A(null)])})]))),t2=S("StringEncodedBigint",e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}}),t8=_({budget:C(t2),price:C(t2),payment:C(x(F)),owner:C(P())}),t5=_({version:A(1),sender:C(P()),expiration:t6,gasConfig:t8,inputs:x(tN),transactions:x(tq)});function t4(e){return eX(e).replace("0x","")}class t3{constructor(e){this.version=1,this.sender=null==e?void 0:e.sender,this.expiration=null==e?void 0:e.expiration,this.gasConfig=(null==e?void 0:e.gasConfig)??{},this.inputs=(null==e?void 0:e.inputs)??[],this.transactions=(null==e?void 0:e.transactions)??[]}static fromKindBytes(e){var t;let r=tU.TransactionKind.parse(e),i="ProgrammableTransaction"in r?r.ProgrammableTransaction:null;if(!i)throw Error("Unable to deserialize from bytes.");let n=(t={version:1,gasConfig:{},inputs:i.inputs.map((e,t)=>w({kind:"Input",value:e,index:t,type:j(e,tC)?"pure":"object"},tN)),transactions:i.transactions},w(t,t5));return t3.restore(n)}static fromBytes(e){var t,r;let i=tU.TransactionData.parse(e),n=null==i?void 0:i.V1,a="ProgrammableTransaction"in n.kind?null==(t=null==n?void 0:n.kind)?void 0:t.ProgrammableTransaction:null;if(!n||!a)throw Error("Unable to deserialize from bytes.");let s=(r={version:1,sender:n.sender,expiration:n.expiration,gasConfig:n.gasData,inputs:a.inputs.map((e,t)=>w({kind:"Input",value:e,index:t,type:j(e,tC)?"pure":"object"},tN)),transactions:a.transactions},w(r,t5));return t3.restore(s)}static restore(e){b(e,t5);let t=new t3;return Object.assign(t,e),t}static getDigestFromBytes(e){return ej(function(e,t){let r=Array.from(`${e}::`).map(e=>e.charCodeAt(0)),i=new Uint8Array(r.length+t.length);return i.set(r),i.set(t,r.length),(0,s.y)(i,{dkLen:32})}("TransactionData",e))}build({maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}={}){let i=this.inputs.map(e=>(b(e.value,tP),e.value)),n={ProgrammableTransaction:{inputs:i,transactions:this.transactions}};if(r)return tU.TransactionKind.serialize(n,{maxSize:e}).toBytes();let a=(null==t?void 0:t.expiration)??this.expiration,s=(null==t?void 0:t.sender)??this.sender,o={...this.gasConfig,...null==t?void 0:t.gasConfig};if(!s)throw Error("Missing transaction sender");if(!o.budget)throw Error("Missing gas budget");if(!o.payment)throw Error("Missing gas payment");if(!o.price)throw Error("Missing gas price");let l={sender:t4(s),expiration:a||{None:!0},gasData:{payment:o.payment,owner:t4(this.gasConfig.owner??s),price:BigInt(o.price),budget:BigInt(o.budget)},kind:{ProgrammableTransaction:{inputs:i,transactions:this.transactions}}};return tU.TransactionData.serialize({V1:l},{maxSize:e}).toBytes()}getDigest(){let e=this.build({onlyTransactionKind:!1});return t3.getDigestFromBytes(e)}snapshot(){return w(this,t5)}}var t7,t9,re,rt,rr,ri,rn,ra,rs,ro,rl,ru,rc,rd,rf,rh,rp,rg=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},rm=(e,t,r)=>(rg(e,t,"read from private field"),r?r.call(e):t.get(e)),ry=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},rb=(e,t,r,i)=>(rg(e,t,"write to private field"),t.set(e,r),r),rw=(e,t,r)=>(rg(e,t,"access private method"),r);let rv={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function rj(e){if(!e.client)throw Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}let rk=Symbol.for("@mysten/transaction"),rT={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},rS=(e,t)=>Array.from({length:Math.ceil(e.length/t)},(r,i)=>e.slice(i*t,i*t+t)),rE=class{constructor(e){ry(this,t9),ry(this,rt),ry(this,ri),ry(this,ra),ry(this,ro),ry(this,ru),ry(this,rd),ry(this,rh),ry(this,t7,void 0),rb(this,t7,new t3(e?e.blockData:void 0))}static fromKind(e){let t=new rE;return rb(t,t7,t3.fromKindBytes("string"==typeof e?eT(e):e)),t}static from(e){let t=new rE;return"string"==typeof e&&e.startsWith("{")?rb(t,t7,t3.restore(JSON.parse(e))):rb(t,t7,t3.fromBytes("string"==typeof e?eT(e):e)),t}setSender(e){rm(this,t7).sender=e}setSenderIfNotSet(e){rm(this,t7).sender||(rm(this,t7).sender=e)}setExpiration(e){rm(this,t7).expiration=e}setGasPrice(e){rm(this,t7).gasConfig.price=String(e)}setGasBudget(e){rm(this,t7).gasConfig.budget=String(e)}setGasOwner(e){rm(this,t7).gasConfig.owner=e}setGasPayment(e){rm(this,t7).gasConfig.payment=e.map(e=>v(e,F))}get blockData(){return rm(this,t7).snapshot()}get[rk](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:function(e){function t(t,r){return e(t,r)}return t.u8=t=>e(tU.U8.serialize(t)),t.u16=t=>e(tU.U16.serialize(t)),t.u32=t=>e(tU.U32.serialize(t)),t.u64=t=>e(tU.U64.serialize(t)),t.u128=t=>e(tU.U128.serialize(t)),t.u256=t=>e(tU.U256.serialize(t)),t.bool=t=>e(tU.Bool.serialize(t)),t.string=t=>e(tU.String.serialize(t)),t.address=t=>e(tU.Address.serialize(t)),t.id=t.address,t}((e,t)=>eF(e)?rw(this,t9,re).call(this,"pure",{Pure:Array.from(e.toBytes())}):rw(this,t9,re).call(this,"pure",e instanceof Uint8Array?tM.Pure(e):t?tM.Pure(e,t):e))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if("object"==typeof e&&"kind"in e)return e;let t=tR(e),r=rm(this,t7).inputs.find(e=>"object"===e.type&&t===tR(e.value));return r&&j(r.value,tz)&&"Shared"in r.value.Object&&j(e,tz)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??rw(this,t9,re).call(this,"object","string"==typeof e?eX(e):e)}objectRef(...e){return this.object(tM.ObjectRef(...e))}receivingRef(...e){return this.object(tM.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(tM.SharedObjectRef(...e))}add(e){return function(e){let t=[],r=r=>t[r]??(t[r]={kind:"NestedResult",index:e,resultIndex:r});return new Proxy({kind:"Result",index:e},{set(){throw Error("The transaction result is a proxy, and does not support setting properties directly")},get(e,t){if(t in e)return Reflect.get(e,t);if(t===Symbol.iterator)return function*(){let e=0;for(;;)yield r(e),e++};if("symbol"==typeof t)return;let i=parseInt(t,10);if(!(Number.isNaN(i)||i<0))return r(i)}})}(rm(this,t7).transactions.push(e)-1)}splitCoins(e,t){return this.add(tY("string"==typeof e?this.object(e):e,t.map(e=>"number"==typeof e||"bigint"==typeof e||"string"==typeof e?this.pure.u64(e):rw(this,rt,rr).call(this,e))))}mergeCoins(e,t){return this.add(tZ("string"==typeof e?this.object(e):e,t.map(e=>"string"==typeof e?this.object(e):e)))}publish({modules:e,dependencies:t}){return this.add(tQ({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,packageId:r,ticket:i}){return this.add(t0({modules:e,dependencies:t,packageId:r,ticket:"string"==typeof i?this.object(i):i}))}moveCall({arguments:e,typeArguments:t,target:r}){return this.add(tX({arguments:null==e?void 0:e.map(e=>rw(this,rt,rr).call(this,e)),typeArguments:t,target:r}))}transferObjects(e,t){return this.add(tH(e.map(e=>"string"==typeof e?this.object(e):e),"string"==typeof t?this.pure.address(t):rw(this,rt,rr).call(this,t)))}makeMoveVec({type:e,objects:t}){return this.add(t1({type:e,objects:t.map(e=>"string"==typeof e?this.object(e):e)}))}serialize(){return JSON.stringify(rm(this,t7).snapshot())}async sign(e){let{signer:t,...r}=e,i=await this.build(r);return t.signTransactionBlock(i)}async build(e={}){return await rw(this,rh,rp).call(this,e),rm(this,t7).build({maxSizeBytes:rw(this,ri,rn).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await rw(this,rh,rp).call(this,e),rm(this,t7).getDigest()}};t7=new WeakMap,t9=new WeakSet,re=function(e,t){let r=rm(this,t7).inputs.length,i=w({kind:"Input",value:"bigint"==typeof t?String(t):t,index:r,type:e},tN);return rm(this,t7).inputs.push(i),i},rt=new WeakSet,rr=function(e){return eF(e)?this.pure(e):e},ri=new WeakSet,rn=function(e,{protocolConfig:t,limits:r}){if(r&&"number"==typeof r[e])return r[e];if(!t)return rv[e];let i=null==t?void 0:t.attributes[rT[e]];if(!i)throw Error(`Missing expected protocol config: "${rT[e]}"`);let n="u64"in i?i.u64:"u32"in i?i.u32:i.f64;if(!n)throw Error(`Unexpected protocol config value found for: "${rT[e]}"`);return Number(n)},ra=new WeakSet,rs=function(e){let t=rw(this,ri,rn).call(this,"maxPureArgumentSize",e);rm(this,t7).inputs.forEach((e,r)=>{if(j(e.value,tC)&&e.value.Pure.length>t)throw Error(`Input at index ${r} is too large, max pure input size is ${t} bytes, got ${e.value.Pure.length} bytes`)})},ro=new WeakSet,rl=async function(e){if(rm(this,t7).gasConfig.payment){let t=rw(this,ri,rn).call(this,"maxGasObjects",e);if(rm(this,t7).gasConfig.payment.length>t)throw Error(`Payment objects exceed maximum amount: ${t}`)}if(e.onlyTransactionKind||rm(this,t7).gasConfig.payment)return;let t=rm(this,t7).gasConfig.owner??rm(this,t7).sender,r=(await rj(e).getCoins({owner:t,coinType:eZ})).data.filter(e=>!rm(this,t7).inputs.find(t=>!!j(t.value,tP)&&"Object"in t.value&&"ImmOrOwned"in t.value.Object&&e.coinObjectId===t.value.Object.ImmOrOwned.objectId)).slice(0,rw(this,ri,rn).call(this,"maxGasObjects",e)-1).map(e=>({objectId:e.coinObjectId,digest:e.digest,version:e.version}));if(!r.length)throw Error("No valid gas coins found for the transaction.");this.setGasPayment(r)},ru=new WeakSet,rc=async function(e){e.onlyTransactionKind||rm(this,t7).gasConfig.price||this.setGasPrice(await rj(e).getReferenceGasPrice())},rd=new WeakSet,rf=async function(e){let{inputs:t,transactions:r}=rm(this,t7),i=[],n=[];if(t.forEach(e=>{if("object"===e.type&&"string"==typeof e.value){n.push({id:eX(e.value),input:e});return}}),r.forEach(e=>{if("MoveCall"===e.kind&&e.arguments.some(e=>"Input"===e.kind&&!j(t[e.index].value,tP))&&i.push(e),"SplitCoins"===e.kind&&e.amounts.forEach(e=>{if("Input"===e.kind){let r=t[e.index];"object"!=typeof r.value&&(r.value=tM.Pure(tU.U64.serialize(r.value)))}}),"TransferObjects"===e.kind&&"Input"===e.address.kind){let r=t[e.address.index];"object"!=typeof r.value&&(r.value=tM.Pure(tU.Address.serialize(r.value)))}}),i.length&&await Promise.all(i.map(async r=>{let[i,a,s]=r.target.split("::"),o=await rj(e).getNormalizedMoveFunction({package:eH(i),module:a,function:s}),l=o.parameters.length>0&&function(e){var t;let r=null==(t=eb(e))?void 0:t.Struct;return(null==r?void 0:r.address)==="0x2"&&(null==r?void 0:r.module)==="tx_context"&&(null==r?void 0:r.name)==="TxContext"}(o.parameters.at(-1))?o.parameters.slice(0,o.parameters.length-1):o.parameters;if(l.length!==r.arguments.length)throw Error("Incorrect number of arguments.");l.forEach((e,i)=>{let a=r.arguments[i];if("Input"!==a.kind)return;let s=t[a.index];if(j(s.value,tP))return;let o=s.value,l=function e(t,r){if("string"==typeof t&&e5.includes(t)){if(t in["U8","U16","U32","U64","U128","U256"])e8("number",r);else if("Bool"===t)e8("boolean",r);else{var i,n;if("Address"===t&&(e8("string",r),r&&(i=r,!/^(0x|0X)?[a-fA-F0-9]+$/.test(i)||i.length%2!=0||32!=(n=r,/^(0x|0X)/.test(n)?(n.length-2)/2:n.length/2))))throw Error("Invalid Sui Address")}return t.toLowerCase()}if("string"==typeof t)throw Error(`Unknown pure normalized type ${JSON.stringify(t,null,2)}`);if("Vector"in t){if((void 0===r||"string"==typeof r)&&"U8"===t.Vector)return"string";if(void 0!==r&&!Array.isArray(r))throw Error(`Expect ${r} to be a array, received ${typeof r}`);let i=e(t.Vector,r?r[0]:void 0);return void 0===i?void 0:`vector<${i}>`}if("Struct"in t){if(e2(t.Struct,e0))return"string";if(e2(t.Struct,e1))return"utf8string";if(e2(t.Struct,eQ))return"address";if(e2(t.Struct,e6))return e({Vector:t.Struct.typeArguments[0]},r)}}(e,o);if(l){s.value=tM.Pure(o,l);return}if(null!=eb(e)||"object"==typeof e&&"TypeParameter"in e){if("string"!=typeof o)throw Error(`Expect the argument to be an object id string, got ${JSON.stringify(o,null,2)}`);n.push({id:o,input:s,normalizedType:e});return}throw Error(`Unknown call arg type ${JSON.stringify(e,null,2)} for value ${JSON.stringify(o,null,2)}`)})})),n.length){let t=[...new Set(n.map(({id:e})=>e))],r=rS(t,50),i=(await Promise.all(r.map(t=>rj(e).multiGetObjects({ids:t,options:{showOwner:!0}})))).flat(),a=new Map(t.map((e,t)=>[e,i[t]])),s=Array.from(a).filter(([e,t])=>t.error).map(([e,t])=>e);if(s.length)throw Error(`The following input objects are invalid: ${s.join(", ")}`);n.forEach(({id:e,input:t,normalizedType:r})=>{var i,n,s;let o=a.get(e),l=null==(i=o.data)?void 0:i.owner,u=l&&"object"==typeof l&&"Shared"in l?l.Shared.initial_shared_version:void 0;if(u){let i=null!=r&&null==em(r)&&null==ey(r),a=((null==(n="object"==typeof(s=t.value)&&"Object"in s&&"Shared"in s.Object?s.Object.Shared:void 0)?void 0:n.mutable)??!1)||i||null!=r&&null!=em(r);t.value=tM.SharedObjectRef({objectId:e,initialSharedVersion:u,mutable:a})}else r&&function(e){let t=eb(e);return!!t&&"0x2"===t.Struct.address&&"transfer"===t.Struct.module&&"Receiving"===t.Struct.name}(r)?t.value=tM.ReceivingRef(er(o)):t.value=tM.ObjectRef(er(o))})}},rh=new WeakSet,rp=async function(e){if(!e.onlyTransactionKind&&!rm(this,t7).sender)throw Error("Missing transaction sender");if(e.protocolConfig||e.limits||!e.client||(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([rw(this,ru,rc).call(this,e),rw(this,rd,rf).call(this,e)]),!e.onlyTransactionKind&&(await rw(this,ro,rl).call(this,e),!rm(this,t7).gasConfig.budget)){let t=await rj(e).dryRunTransactionBlock({transactionBlock:rm(this,t7).build({maxSizeBytes:rw(this,ri,rn).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(rw(this,ri,rn).call(this,"maxTxGas",e)),payment:[]}}})});if("success"!==t.effects.status.status)throw Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});let r=1000n*BigInt(this.blockData.gasConfig.price||1n),i=BigInt(t.effects.gasUsed.computationCost)+r,n=i+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(n>i?n:i)}rw(this,ra,rs).call(this,e)};let rx=async(e,t,r)=>{var i,n,a;if(!(0,s.ck)(r))throw Error(`Invalid Sui type: ${r}`);let l=await (0,o.g)(e,t);if(!l)throw Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);let u=null==(n=null==(i=l.token_registry.fields)?void 0:i.id)?void 0:n.id;if(!u)throw Error("Unable to fetch token registry object ID");let c=(0,s.I)(null==(a=l.token_registry)?void 0:a.type);if(!c)throw Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:u,name:{type:`${c}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},rI=async(e,t,r,i)=>{var n,a,l,u;let c=await (0,o.g)(e,t);if(!c)throw Error("Unable to fetch object fields from token bridge state");let d=null==(a=null==(n=c.token_registry)?void 0:n.fields)?void 0:a.coin_types,f=null==(u=null==(l=null==d?void 0:d.fields)?void 0:l.id)?void 0:u.id;if(!f)throw Error("Unable to fetch coin types");let h=(0,s.cl)(null==d?void 0:d.type);if(!h)throw Error("Unable to get key type");let p=await e.getDynamicFieldObject({parentId:f,name:{type:h,value:{addr:[...r],chain:i}}});if(p.error){if("dynamicFieldNotFound"===p.error.code)return null;throw Error(`Unexpected getDynamicFieldObject response ${p.error}`)}let g=(0,o.a)(p);if(!g)return null;if(!(0,o.i)(g))throw Error("What?");return"value"in g?(0,s.cm)(g.value):null};class rO{constructor(e,t,r,i){d(this,"network"),d(this,"chain"),d(this,"provider"),d(this,"contracts"),d(this,"coreBridgeObjectId"),d(this,"tokenBridgeObjectId"),d(this,"chainId"),this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=(0,s.b8).get(e,t);let n=this.contracts.tokenBridge;if(!n)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);let a=this.contracts.coreBridge;if(!a)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=n,this.coreBridgeObjectId=a}static async fromRpc(e,t){let[r,i]=await (0,o.S).chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch: ${n.network} != ${r}`);return new rO(r,i,e,n.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,s.ck)(t))throw Error(`Invalid Sui type: ${t}`);let r=await rx(this.provider,this.tokenBridgeObjectId,t),i=(0,o.a)(r);if(!i)throw(0,s.bA)(t);if(!(0,o.i)(i))throw Error("Expected fields to be a MoveStruct");if(!("value"in i))throw Error("Expected a `value` key in fields of MoveStruct");let n=i.value;if(!(0,o.b)(n))throw Error("Expected fields to be a MoveStruct");let a=(0,s.cm)(n.type);if(t=(0,s.cm)(t),a.includes(`wrapped_asset::WrappedAsset<${t}>`)){let e=n.fields.info;if(!(0,o.b)(e))throw Error("Expected fields to be a MoveStruct");let t=e.fields.token_address;if(!(0,o.b)(t))throw Error("Expected fields to be a MoveStruct");if(!(0,o.i)(t.fields))throw Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw Error("Expected a `value` key in fields of MoveStruct");let r=t.fields.value;if(!(0,o.b)(r))throw Error("Expected fields to be a MoveStruct");let i=new Uint8Array(r.fields.data);return{chain:(0,s.bd)(Number(e.fields.token_chain)),address:new s.bB(i)}}throw(0,s.bA)(t)}async getTokenUniversalAddress(e){let t=e.getCoinType();if(!(0,s.ck)(t))throw Error(`Invalid Sui type: ${t}`);let r=await rx(this.provider,this.tokenBridgeObjectId,t),i=(0,o.a)(r);if(!i)throw Error(`Token of type ${t} has not been registered with the token bridge. Has it been attested?`);if(!(0,o.i)(i))throw Error("Expected fields to be a MoveStruct");if(!("value"in i))throw Error("Expected a `value` key in fields of MoveStruct");let n=i.value;if(!(0,o.b)(n))throw Error("Expected fields to be a MoveStruct");let a=(0,s.cm)(n.type);if(t=(0,s.cm)(t),a.includes(`native_asset::NativeAsset<${t}>`)){let e=n.fields.token_address;if(!(0,o.b)(e))throw Error("Expected fields to be a MoveStruct");if(!("value"in e.fields))throw Error("Expected a `value` key in fields of MoveStruct");let t=e.fields.value;if(!(0,o.b)(t))throw Error("Expected fields to be a MoveStruct");let r=new Uint8Array(t.fields.data);return new s.bB(r)}throw Error(`Token of type ${t} is not a native asset`)}async getTokenNativeAddress(e,t){let r=await rI(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),(0,s.b6)(e));if(!r)throw Error(`Token ${t.toString()} not found in token registry`);return new s.K(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if((0,s.m)(e.address))throw Error("Token Address required, 'native' literal not supported");let t=await rI(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,s.b6)(e.chain));if(!t)throw(0,s.bA)((0,s.ba)(e));return(0,s.bG)(this.chain,t)}async isTransferCompleted(e){var t,r,i,n,a,l,u,c;let d=await (0,o.g)(this.provider,this.tokenBridgeObjectId);if(!d)throw Error("Unable to fetch object fields from token bridge state");let f=null==(r=null==(t=d.consumed_vaas)?void 0:t.fields)?void 0:r.hashes,h=(0,s.cl)(null==(n=null==(i=null==f?void 0:f.fields)?void 0:i.items)?void 0:n.type);if(!h)throw Error("Unable to get key type");let p=null==(c=null==(u=null==(l=null==(a=null==f?void 0:f.fields)?void 0:a.items)?void 0:l.fields)?void 0:u.id)?void 0:c.id;if(!p)throw Error("Unable to fetch consumed VAAs table");let g=await this.provider.getDynamicFieldObject({parentId:p,name:{type:h,value:{data:[...(0,s.bD)(e.hash)]}}});if(!g.error)return!0;if("dynamicFieldNotFound"===g.error.code)return!1;throw Error(`Unexpected getDynamicFieldObject response ${g.error}`)}async *createAttestation(e){let t=e.toString(),r=await this.provider.getCoinMetadata({coinType:t});if(null===r||null===r.id)throw Error(`Coin metadata ID for type ${t} not found`);let[i,n]=await this.getPackageIds(),a=new rE,[s]=a.splitCoins(a.gas,[a.pure(0n)]),[o]=a.moveCall({target:`${n}::attest_token::attest_token`,arguments:[a.object(this.tokenBridgeObjectId),a.object(r.id),a.pure(0n)],typeArguments:[t]});a.moveCall({target:`${i}::publish_message::publish_message`,arguments:[a.object(this.coreBridgeObjectId),s,o,a.object(eY)]}),yield this.createUnsignedTx(a,"Sui.TokenBridge.CreateAttestation")}async *submitAttestation(e,t){let[r,i]=await this.getPackageIds(),n=t.toString(),a=Math.min(e.payload.decimals,8),l=await this.getCoinBuildOutput(r,i,a),u=await (0,o.p)(l,n);yield this.createUnsignedTx(u,"Sui.TokenBridge.PrepareCreateWrapped");let c="",d="",f="",h="",p="",g=!1;for(;!g;)for(let e of(await new Promise(e=>setTimeout(e,500)),(await this.provider.queryTransactionBlocks({filter:{FromAddress:n},options:{showObjectChanges:!0},limit:3})).data))if("objectChanges"in e){for(let t of e.objectChanges)(0,o.c)(t)&&void 0!==t.packageId?c=t.packageId:(0,o.d)(t)&&t.objectType.includes("WrappedAssetSetup")?(d=t.objectId,p=t.objectType.split(", ")[1].replace(">","")):(0,o.d)(t)&&t.objectType.includes("UpgradeCap")?f=t.objectId:(0,o.d)(t)&&t.objectType.includes("CoinMetadata")&&(h=t.objectId);if(""!==c&&""!==d&&""!==f&&""!==h){g=!0;break}c="",d="",f="",h=""}let m=(0,s.cn)(c),y=new rE,[b]=y.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[y.object(this.coreBridgeObjectId),y.pure((0,o.u)((0,s.be)(e))),y.object(eY)]}),[w]=y.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[y.object(this.tokenBridgeObjectId),b]});y.moveCall({target:`${i}::create_wrapped::complete_registration`,arguments:[y.object(this.tokenBridgeObjectId),y.object(h),y.object(d),y.object(f),w],typeArguments:[m,p]}),yield this.createUnsignedTx(y,"Sui.TokenBridge.SubmitAttestation")}async *transfer(e,t,r,i,n){let a=e.toString(),l=((0,s.m)(r)?eZ:r).toString(),[u,...c]=(await (0,o.S).getCoins(this.provider,e,l)).filter(e=>(0,o.e)(e.coinType,l));if(void 0===u)throw Error(`Coins array doesn't contain any coins of type ${l}`);let[d,f]=await this.getPackageIds(),h=new rE,[p]=(()=>{if(l===eZ)return h.splitCoins(h.gas,[h.pure(i)]);{let e=h.object(u.coinObjectId);return c.length&&h.mergeCoins(e,c.map(e=>h.object(e.coinObjectId))),h.splitCoins(e,[h.pure(i)])}})(),[g]=h.splitCoins(h.gas,[h.pure(0n)]),[m]=h.moveCall({target:`${f}::state::verified_asset`,arguments:[h.object(this.tokenBridgeObjectId)],typeArguments:[l]});if(n){if(!a)throw Error("senderAddress is required for transfer with payload");let e=!1,r=await (async()=>{let t=await (0,o.f)(this.provider,d,a);if(null!==t)return h.object(t);{let[t]=h.moveCall({target:`${d}::emitter::new`,arguments:[h.object(this.coreBridgeObjectId)]});return e=!0,t}})(),[i,u]=h.moveCall({target:`${f}::transfer_tokens_with_payload::prepare_transfer`,arguments:[r,m,p,h.pure((0,s.b6)(t.chain)),h.pure(t.address.toUint8Array()),h.pure([...n]),h.pure(0)],typeArguments:[l]});h.moveCall({target:`${f}::coin_utils::return_nonzero`,arguments:[u],typeArguments:[l]});let[c]=h.moveCall({target:`${f}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[h.object(this.tokenBridgeObjectId),i],typeArguments:[l]});h.moveCall({target:`${d}::publish_message::publish_message`,arguments:[h.object(this.coreBridgeObjectId),g,c,h.object(eY)]}),e&&h.transferObjects([r],h.pure(a)),yield this.createUnsignedTx(h,"Sui.TokenBridge.TransferWithPayload")}else{let[e,r]=h.moveCall({target:`${f}::transfer_tokens::prepare_transfer`,arguments:[m,p,h.pure((0,s.b6)(t.chain)),h.pure((0,o.u)(t.address.toUint8Array())),h.pure(0n),h.pure(0)],typeArguments:[l]});h.moveCall({target:`${f}::coin_utils::return_nonzero`,arguments:[r],typeArguments:[l]});let[i]=h.moveCall({target:`${f}::transfer_tokens::transfer_tokens`,arguments:[h.object(this.tokenBridgeObjectId),e],typeArguments:[l]});h.moveCall({target:`${d}::publish_message::publish_message`,arguments:[h.object(this.coreBridgeObjectId),g,i,h.object(eY)]}),yield this.createUnsignedTx(h,"Sui.TokenBridge.Transfer")}}async *redeem(e,t,r=!0){let i=await rI(this.provider,this.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,s.b6)(t.payload.token.chain));if(!i)throw Error("Unable to fetch token coinType");let[n,a]=await this.getPackageIds(),l=new rE,[u]=l.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[l.object(this.coreBridgeObjectId),l.pure((0,o.u)((0,s.be)(t))),l.object(eY)]}),[c]=l.moveCall({target:`${a}::vaa::verify_only_once`,arguments:[l.object(this.tokenBridgeObjectId),u]}),[d]=l.moveCall({target:`${a}::complete_transfer::authorize_transfer`,arguments:[l.object(this.tokenBridgeObjectId),c],typeArguments:[i]}),[f]=l.moveCall({target:`${a}::complete_transfer::redeem_relayer_payout`,arguments:[d],typeArguments:[i]});l.moveCall({target:`${a}::coin_utils::return_nonzero`,arguments:[f],typeArguments:[i]}),yield this.createUnsignedTx(l,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return(0,s.bG)(this.chain,eZ)}async getPackageIds(){return Promise.all([(0,o.h)(this.provider,this.coreBridgeObjectId),(0,o.h)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){var i;if(r>8)throw Error("Decimals is capped at 8");let n=null==(i=await (0,o.j)(this.provider,this.tokenBridgeObjectId))?void 0:i.replace("0x","");if(!n)throw Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);let a="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+n+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[(0,s.H).encode((0,s.r).decode(a))],dependencies:["0x1","0x2",t,e].map(e=>eH(e))}}createUnsignedTx(e,t,r=!1){return new l.S(e,this.network,this.chain,t,r)}}class rA{constructor(e,t,r,i){d(this,"network"),d(this,"chain"),d(this,"connection"),d(this,"contracts"),d(this,"tokenBridgeRelayerObjectId"),d(this,"coreBridgeObjectId"),d(this,"tokenBridgeObjectId"),d(this,"fields"),this.network=e,this.chain=t,this.connection=r,this.contracts=i;let{tokenBridge:n,tokenBridgeRelayer:a,coreBridge:s}=i;if(!n||!a||!s)throw Error(`Some object IDs for ${t} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=a,this.tokenBridgeObjectId=n,this.coreBridgeObjectId=s}static async fromRpc(e,t){let[r,i]=await (0,o.S).chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch for chain ${i}: ${n.network} != ${r}`);return new rA(r,i,e,n.contracts)}async *transfer(e,t,r,i,n){let a=new(0,s.K)((0,s.m)(r)?(0,o.S).nativeTokenId(this.network,this.chain).address:r).getCoinType(),{coreBridge:l,tokenBridge:u}=await this.getPackageIds(),c=new rE,d=BigInt(0),[f]=c.splitCoins(c.gas,[c.pure(d)]),[h]=await (async()=>{if((0,s.m)(r))return c.splitCoins(c.gas,[c.pure(i)]);{let[t,...r]=(await (0,o.S).getCoins(this.connection,e,a)).filter(e=>e.coinType===a);if(void 0===t)throw Error(`Coins array doesn't contain any coins of type ${a}`);let n=c.object(t.coinObjectId);return r.length&&c.mergeCoins(n,r.map(e=>c.object(e.coinObjectId))),c.splitCoins(n,[c.pure(i)])}})(),[p]=c.moveCall({target:`${u}::state::verified_asset`,arguments:[c.object(this.tokenBridgeObjectId)],typeArguments:[a]}),g=await this.getPackageId(),[m]=c.moveCall({target:`${g}::transfer::transfer_tokens_with_relay`,arguments:[c.object(this.tokenBridgeRelayerObjectId),h,p,c.pure.u64(n??0n),c.pure.u16((0,s.b6)(t.chain)),c.pure.address((0,s.r).encode(t.address.toUint8Array(),!0)),c.pure.u32(123)],typeArguments:[a]}),[y]=c.moveCall({target:`${u}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[c.object(this.tokenBridgeObjectId),m],typeArguments:[a]});c.moveCall({target:`${l}::publish_message::publish_message`,arguments:[c.object(this.coreBridgeObjectId),f,y,c.object(eY)]}),yield this.createUnsignedTx(c,"AutomaticTokenBridge.transfer")}async *redeem(e,t){let{coreBridge:r,tokenBridge:i}=await this.getPackageIds(),{address:n,chain:a}=t.payload.token,l=await rI(this.connection,this.tokenBridgeObjectId,n.toUniversalAddress().toUint8Array(),(0,s.b6)(a));if(!l)throw Error("Unable to fetch token coinType");let u=new rE,[c]=u.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[u.object(this.coreBridgeObjectId),u.pure((0,o.u)((0,s.be)(t))),u.object(eY)]}),[d]=u.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[u.object(this.tokenBridgeObjectId),c]}),[f]=u.moveCall({target:`${i}::complete_transfer_with_payload::authorize_transfer`,arguments:[u.object(this.tokenBridgeObjectId),d],typeArguments:[l]}),h=await this.getPackageId();u.moveCall({target:`${h}::redeem::complete_transfer`,arguments:[u.object(this.tokenBridgeRelayerObjectId),f],typeArguments:[l]}),yield this.createUnsignedTx(u,"AutomaticTokenBridge.redeem")}async getRelayerFee(e,t){let r=(0,s.m)(t)?(0,o.S).nativeTokenId(this.network,this.chain):t,i=await this.getTokenInfo(r.toString());if(null===i)throw Error("Unsupported token for relay");let n=await this.getFields(),a=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from((0,s.c9).encode("relayer_fees"))}});if(!a.data||!a.data.content)throw a.error?Error("Failed to get relayer fees: "+JSON.stringify(a.error)):Error("Unable to compute relayer fee");let{content:l}=a.data;if(!(0,o.b)(l)||!(0,o.k)(l.fields.id))throw Error("Unable to compute relayer fee");let u=await this.connection.getDynamicFieldObject({parentId:l.fields.id.id,name:{type:"u16",value:(0,s.b6)(e)}});if(!u.data||!u.data.content)throw u.error?Error("Failed to get relayer fees: "+JSON.stringify(a.error)):Error("Unable to compute relayer fee");let{content:c}=u.data;if(!(0,o.b)(c))throw Error("Unable to compute relayer fee");let d=await (0,o.S).getDecimals(this.chain,this.connection,t.toString()),f=i.swap_rate,h=n.relayer_fee_precision,p=n.swap_rate_precision,g=c.fields.value;return 10n**BigInt(d)*BigInt(g)*BigInt(p)/(BigInt(f)*BigInt(h))}async maxSwapAmount(e){var t,r;let i=((0,s.m)(e)?(0,o.S).nativeTokenId(this.network,this.chain):e).toString(),n=await this.connection.getCoinMetadata({coinType:i});if(!n)throw Error("metadata is null");let a=await this.getPackageId(),l=new rE;l.moveCall({target:`${a}::redeem::calculate_max_swap_amount_in`,arguments:[l.object(this.tokenBridgeRelayerObjectId),l.pure(n.decimals)],typeArguments:[i]});let u=await this.connection.devInspectTransactionBlock({transactionBlock:l,sender:(0,s.r).encode(new Uint8Array(32))});if(!u.results||0==u.results.length||!(null!=(t=u.results[0])&&t.returnValues)||(null==(r=u.results[0])?void 0:r.returnValues.length)!==1)throw Error("swap rate not set");return(0,s.bR).decode(new Uint8Array(u.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,t){var r,i;let n=((0,s.m)(e)?(0,o.S).nativeTokenId(this.network,this.chain):e).toString(),a=await this.connection.getCoinMetadata({coinType:n});if(!a)throw Error("metadata is null");let l=await this.getPackageId(),u=new rE;u.moveCall({target:`${l}::redeem::calculate_native_swap_amount_out`,arguments:[u.object(this.tokenBridgeRelayerObjectId),u.pure(t),u.pure(a.decimals)],typeArguments:[n]});let c=await this.connection.devInspectTransactionBlock({transactionBlock:u,sender:(0,s.r).encode(new Uint8Array(32))});if(!c.results||0==c.results.length||!(null!=(r=c.results[0])&&r.returnValues)||(null==(i=c.results[0])?void 0:i.returnValues.length)!==1)throw Error("swap rate not set");return(0,s.bR).decode(new Uint8Array(c.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){let e=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:e})).data.map(e=>{let{address:t,module:r,name:i}=function e(t){let[r,i]=t.split("::"),n=t.slice(r.length+i.length+4),a=n.includes("<")?n.slice(0,n.indexOf("<")):n,s=n.includes("<")?eA(n.slice(n.indexOf("<")+1,n.lastIndexOf(">"))).map(t=>{var r;return(r=t.trim()).includes("::")?e(r):r}):[];return{address:eX(r),module:i,name:a,typeParams:s}}(e.objectType).typeParams[0];return new s.K([t,r,i].join(s.co))})}async isRegisteredToken(e){let t=new(0,s.K)((0,s.m)(e)?(0,o.S).nativeTokenId(this.network,this.chain).address:e).unwrap();try{return await this.getTokenInfo(t)!==null}catch(e){console.error(e)}return!1}async getTokenInfo(e){var t;let r=await this.getFields(),i=new(0,s.K)(r.registered_tokens.type).getPackageId(),n=r.registered_tokens.fields.id.id,a=new s.K(e),l=(0,o.e)(s.J,a.unwrap())?s.J:a.getCoinType();try{let e=await this.connection.getDynamicFieldObject({parentId:n,name:{type:`${i}::registered_tokens::Key<${l}>`,value:{dummy_field:!1}}});if(e.error)throw Error("Failed to get token info: "+JSON.stringify(e.error));if(!e.data||!e.data.content)throw Error("Failed to get token info: "+JSON.stringify(e));let{content:t}=e.data;return(0,o.b)(t)&&(0,o.b)(t.fields.value)?t.fields.value.fields:null}catch(e){if((null==e?void 0:e.code)===-32e3&&null!=(t=e.message)&&t.includes("RPC Error"))return console.error(e),null;throw e}}async getFields(){if(!this.fields){let e=await (0,o.g)(this.connection,this.tokenBridgeRelayerObjectId);if(null===e)throw Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){let e=await this.getFields();return new(0,s.K)(e.registered_tokens.type).getPackageId()}async getPackageIds(){let[e,t]=await Promise.all([(0,o.h)(this.connection,this.coreBridgeObjectId),(0,o.h)(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:t}}createUnsignedTx(e,t,r=!1){return new l.S(e,this.network,this.chain,t,r)}}(0,s.bj)("Sui","TokenBridge",rO),(0,s.bj)("Sui","AutomaticTokenBridge",rA)},{"./index-DTF6KsXj.mjs":"ieLDt","./sui-Dhwkelcg.mjs":"dxzPC","./index-Clp6Yk3p.mjs":"iyKkP","./unsignedTransaction-BD81leu1.mjs":"eqkOn","@parcel/transformer-js/src/esmodule-helpers.js":"jiucr"}],eqkOn:[function(e,t,r,i){var n=e("@parcel/transformer-js/src/esmodule-helpers.js");n.defineInteropFlag(r),n.export(r,"S",()=>l);var a=Object.defineProperty,s=(e,t,r)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,o=(e,t,r)=>s(e,"symbol"!=typeof t?t+"":t,r);class l{constructor(e,t,r,i,n=!1){o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=i,this.parallelizable=n}}},{"@parcel/transformer-js/src/esmodule-helpers.js":"jiucr"}]},[],0,"parcelRequire94c2");
//# sourceMappingURL=index-CpN8LFA_.9a570443.js.map
